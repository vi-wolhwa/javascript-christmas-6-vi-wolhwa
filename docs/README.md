# 4주차 미션 - 크리스마스 프로모션

## 1. 혜택 조회 정보 입력

### 1-1. 머리말
- ⬜ 머리말 출력 : `안녕하세요! 우테코 식당 ${month}월 이벤트 플래너입니다.`

### 1-2. 방문 날짜
- ⬜ 안내메시지 출력 : `${month}월 중 식당 예상 방문 날짜는 언제인가요? (숫자만 입력해 주세요!)`
- ⬜ 방문 날짜 입력
- 유효성 검사
  - ⬜ `[ERROR] 유효하지 않은 날짜입니다. 다시 입력해 주세요.`
    - 1~31 사이의 정수가 아닌 경우 (정수검사 + 범위검사)
- ⬜ 방문 날짜 정보 저장

### 1-3. 메뉴 주문
- ⬜ 안내메시지 출력 : `주문하실 메뉴와 개수를 알려 주세요. (e.g. 해산물파스타-2,레드와인-1,초코케이크-1)`
- ⬜ 주문 내용 입력
- ⬜ 주문 내용 전처리
- 유효성 검사
  - ⬜ `[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요.`
    - 중복 메뉴를 입력한 경우
    - 메뉴판에 없는 메뉴를 입력하는 경우
    - 메뉴의 개수가 1 이상의 숫자가 아닌 경우
    - 메뉴 형식이 예시와 다른 경우</br>
    ( ⚠ 공백 오입력은 허용한다 ) : "해산물 파스타 - 2, ..."</br>
    ( ⚠ 앞/뒤/중복 콤바는 허용한다 ) : ",레드와인-1, ,타파스-1."
  - ⬜ `[ERROR] 메뉴는 한 번에 최대 20개까지만 주문할 수 있습니다.`
    - 총 주문 메뉴가 20개를 초과할 경우
  - ⬜ `[ERROR] 음료만 주문 시, 주문할 수 없습니다.`
    - 음료만 주문한 경우
- ⬜ 주문 정보 저장

***

## 2. 주문 결과/혜택 안내

### 2-1. 머리말
- ⬜ 머리말 출력 : `${month}월 ${day}일에 우테코 식당에서 받을 이벤트 혜택 미리 보기!`

### 2-2. 주문 메뉴
- ⬜ 타이틀 출력 : `<주문 메뉴>`
- ⬜ 주문 메뉴 목록 출력 : `${메뉴명} ${개수}개`</br>
( ⚠ 메뉴의 출력 순서는 무관하다 )

### 2-3. 할인 전 총주문 금액
- ⬜ 타이틀 출력 : `<할인 전 총주문 금액>`
- ⬜ 주문 금액 출력 : `${금액}원`</br>
( ⚠ 금액은 천단위 구분자가 사용된다 )
- ⬜ 총 주문 금액 계산

### 2-4. 증정 메뉴
- ⬜ 타이틀 출력 : `<증정 메뉴>`
- ⬜ 증정 메뉴 출력 : `없음` | `샴페인 1개`
- ⬜ 증정 메뉴 결정 : 할인 전 총주문 금액이 12만 원 이상 → 삼페인 1개

### 2-5. 혜택 내역
- ⬜ 타이틀 출력 : `<혜택 내역>`
- ⬜ 혜택 내역 출력 : `없음` | `${혜택이름}: ${할인금액 * (-1)}원`</br>
( ⚠ 혜택의 출력 순서는 무관하다 )
- ⬜ 이벤트 대상 여부 판단
  - 최소주문금액 : 10,000 원
  - 각 이벤트 조건 비교

### 2-6. 총 혜택 금액
- ⬜ 타이틀 출력 : `<총혜택 금액>`
- ⬜ 혜택 금액 출력 : `${금액 * (-1)}원`</br>
( ⚠ 금액은 천단위 구분자가 사용된다 )
- ⬜ 총 할인 금액 계산
- ⬜ 총 혜택 금액 계산 : 총 할인 금액 + 증정 메뉴의 가격

### 2-7. 할인 후 예상 결제 금액
- ⬜ 타이틀 출력 : `<할인 후 예상 결제 금액>`
- ⬜ 결제 금액 출력 : `${금액}원`</br>
( ⚠ 금액은 천단위 구분자가 사용된다 )
- ⬜ 할인 후 예상 결제 금액 = 할인 전 총주문 금액 - 할인 금액

### 2-8. 이벤트 배지
- ⬜ 타이틀 출력 : `<12월 이벤트 배지>`
- ⬜ 이벤트 배지 출력 : `없음` | `별` | `트리` | `산타`
- ⬜ 이벤트 배지 부여 (총 혜택금액)
  - 별 : 5천 원 이상
  - 트리 : 1만 원 이상
  - 산타 : 2만 원 이상

***

## 3. 기타 유틸리티

### 3-1. 날짜 모듈
- ⬜ 요일 반환
  - [년, 월, 일]을 전달하면 요일 반환
- ⬜ 마지막 날짜 반환
  - [년, 월]을 전달하면 달의 마지막 날짜를 반환

### 3-2. Deep Freezing 모듈
- ✅ 객체에 대하여 Deep Freezing 수행

***

## 4. 정적데이터

### 4-1. 메뉴 정보
- 애피타이저
  - 양송이수프 : 6000
  - 타파스 : 5500
  - 시저샐러드 : 8000
- 메인
  - 티본스테이크 : 55000
  - 바비큐립 : 54000
  - 해산물파스타 : 35000
  - 크리스마스파스타 : 25000
- 디저트
  - 초코케이크 : 15000
  - 아이스크림 : 5000
- 음료
  - 제로콜라 : 3000
  - 레드와인 : 60000
  - 샴페인 : 25000

### 4-2. 이벤트 정보
- 크리스마스 디데이 할인
  - 조건 : 날짜(1~25)
  - 금액 : 1000 + ( 100 * ( Day - 1 ) )
- 평일 할인
  - 조건 : 요일(일요일~목요일)
  - 금액 : (디저트 메뉴 개수) * 2023
- 주말 할인
  - 조건 : 요일(금요일,토요일)
  - 금액 : (메인 메뉴 개수) * 2023
- 특별 할인
  - 조건 : 날짜(25) or 요일(일요일)
  - 금액 : 1000
- 증정 이벤트
  - 조건 : (할인 전 총주문 금액) > 12만 원
  - 증정 : 샴페인 1개 (25000)
  
### 4-3. 이벤트 배지
- 별 : >= 5000, < 10000
- 트리 : >= 10000, < 20000
- 산타 : >= 20000
    
### 4-4. 문자열 정보
- 기호
  - null : ' '
  - space : '` `'
  - minus : `-`
- 프롬프트 (inputView)
  - `주문하실 메뉴와 개수를 알려 주세요. (e.g. 해산물파스타-2,레드와인-1,초코케이크-1)`
  - `${month}월 중 식당 예상 방문 날짜는 언제인가요? (숫자만 입력해 주세요!)`
- 메시지 (outputView)
  - `안녕하세요! 우테코 식당 ${month}월 이벤트 플래너입니다.`
  - `${month}월 ${day}일에 우테코 식당에서 받을 이벤트 혜택 미리 보기!`
  - nothing : `없음`
  - 금액포맷 : `${부호}${천단위구분자(숫자)}원`
  (천단위구분자 : 숫자.toLocaleString())
  - 주문메뉴 : `${메뉴명} ${주문개수}개`
  - 할인내용 : `${혜택이름}: ${금액포맷(minus, 할인금액)}`
- 타이틀
  - `<주문 메뉴>`
  - `<할인 전 총주문 금액>`
  - `<증정 메뉴>`
  - `<혜택 내역>`
  - `<총혜택 금액>`
  - `<할인 후 예상 결제 금액>`
  - `<12월 이벤트 배지>`
- 에러메시지
  - `[ERROR] 유효하지 않은 날짜입니다. 다시 입력해 주세요.`
  - `[ERROR] 유효하지 않은 주문입니다. 다시 입력해 주세요.`
  - `[ERROR] 메뉴는 한 번에 최대 20개까지만 주문할 수 있습니다.`
  - `[ERROR] 음료만 주문 시, 주문할 수 없습니다.`

### 4-5. 기타옵션
- Date
  - year : 2023
  - month : 12
  - fistDay : 1
  - LastDay : 유틸에서 검색
  - event
    - christmas: 25
- 입력 문자열 처리
  - 주문 항목 구분자 : `,`
  - 메뉴-개수 구분자 : `-`

***

## ♻ 3주차 → 4주차 개선 포인트

⬜ 객체는 객체스럽게 사용한다.</br>
`객체(model)은 스스로의 상태를 변화시키는 로직만 수행한다고 생각했었다.`</br>
→ 상태를 가지는 객체를 추가했다면 제대로 된 역할을 하도록 구현한다.</br>
→ getter/setter 메소드 사용을 지양한다.</br>

⬜ 필드의 수를 줄이기 위해 노력한다.</br>
`모든 상태 값을 저장하는 필드를 선언하면 확장성이 높을 것이라고 생각했었다.`</br>
→ 저장할 필요가 없는(중간 결과) 값은 함수에서 계산하여 반환하도록 한다.</br>

⬜ 테스트를 위한 코드는 구현 코드에서 분리되어야 한다.</br>
`테스트 코드를 간단하게 만들기 위하여 getter을 생성한 경험이 있다.`</br>
→ 테스트에서만 사용되는 메서드를 구현 코드에 구현하지 않는다.</br>

⬜ 단위 테스트하기 좋은 메서드를 만든다.</br>
`다른 메서드와의 의존성 때문에 항상 단위테스트의 구현이 어려웠다.`</br>
→ 단위 테스트하기 어려운 코드를 분리한다.</br>
